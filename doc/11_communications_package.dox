/*!

\page communicationsPackage Communications Package

\section communicationsPackageOverview Overview

There is no direct communication to the Layer Management service. All communication
must be performed through communication libraries loaded. These libraries can implement
communication through middleware etc. The communication libraries encapsulate these
dependencies and relay command objects similar to a command design pattern to the
control component of the Layer Management Service. This way the service has no
dependencies towards certain ways of communication and the usage of specific
communication libraries can be decided at runtime.

The general procedure for communicators is to establish their specific communication
(IPC, proprietary method, specific bus etc) and provide the message interface described
in chapter 6. When receiving commands on this communication channel the package builds
one or more of the command objects described below and calls the execute method of the
layermanager with these command objects. The command objects contain everything which
is needed to execute the command, the parameters, the type of command etc. Changes to
the list of layers and properties are then performed at a central point within the
layermanager.

An implementation of a communication library must subclass BaseCommunicator and
implement the inherited start() and stop() methods, as well as a way to load the
library dynamically at runtime.

The layermanager searches the provided communicator shared library for two entry points,
which are both mandatory for a communicator library. Their name is specified by the
following naming scheme:

\li \code <Library_Name>* create<Library_Name>(CommandExecutor*, LayerList*) \endcode
\li \code void destroy<Library_Name>(<Library_Name>*) \endcode

In order to be loadable by the layermanager, the created shared library must provide
both of these functions.

\section communicationsPackageExample Example: Create the communication library “MyCommunicator”

(1) Create the class MyCommunicator, which inherits BaseCommunicator

(2) Implement the virtual class functions

\li \code virtual bool start(void) \endcode
\li \code virtual void stop(void) \endcode

(3) Create the static functions (see example source code below)
\li \code
extern "C"
MyCommunicator* createMyCommunicator(CommandExecutor* ex, LayerList* ll)
{
    return new MyCommunicator(ex, ll);
}
\endcode

\li \code
extern "C"
void destroyMyCommunicator(MyCommunicator* comm)
{
    delete comm;
}
\endcode

(4) Implement communication layer of “MyCommunicator”

(5) Link the implementation to a shared library called “libMyCommunicator.so”

\section communicationsPackagePublicInterface Public Interface

See \ref CommunicatorAPI.

\section communicationsPackageCommandObjectReference Command Object Reference

See \ref Commands.

*/
